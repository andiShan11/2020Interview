[toc]

# Leetcode刷题

## 动态规划

## 贪心

## 搜索

## 回溯

## 双指针

## 滑动窗口

## 前缀和

## 单调队列

## 字符串

### `Leetcode 647. ` 回文子串

**问题描述**

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 

示例 1：

输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"

**解题报告**

**方法一：动态规划**

`dp[i][j]` 表示子串 `s[i:j]` 是否是回文串
$$
dp[i][j]=\left\{\begin{matrix}
dp[i+1][j-1] \;\;\;\;if(s[i]==s[j])
\\ 
false\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;if(s[i]!=s[j])
\end{matrix}\right.
$$

时间复杂度：$O(n^2)$

空间复杂度: $O(n^2)$

当然了，还有另外一种时间复杂度在 $O(n^2)$，空间复杂度在 $O(1)$ 的方法。

**方法二：Manacher** 

首先进行字符串预处理，在原始字符串的空隙处插入符号 `#`

`dp[i]` 表示以 `i` 为中心的最长回文串的长度。

时间复杂度：$O(n)$

空间复杂度：$O(n)$

**实现代码**

**方法一：动态规划**

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int n=s.size();
        vector<vector<int>>dp(n, vector<int>(n, 0));
        int ans=0;
        for(int len=0;len<n;len++){
            for(int i=0;i+len<n;i++){
                int j=i+len;
                if(s[i]==s[j]&&(j-i<=2||dp[i+1][j-1])){
                    dp[i][j]=true;
                    ans++;
                }
            }
        }
        return ans;
    }
};
```

```cpp
class Solution{
    public:
        int countSubstrings(string s){
            int n=s.size();
            int ans=0;
            for(int i=0;i<n;i++){
                int l=i, r=i;
                while(1){
                    ans++;
                    l--;
                    r++;
                    if(l<0||r>n)break;
                    if(s[l]!=s[r])break;
                }
            }
            for(int i=0;i<n-1;i++){
                int l=i, r=i+1;
                if(s[l]!=s[r])continue;
                while(1){
                    ans++;
                    l--;
                    r++;
                    if(l<0||r>n)break;
                    if(s[l]!=s[r])break;
                }
            }
            return ans;
        }
};
```

**方法二：Manacher**

```cpp
class Solution{
    public:
        int countSubstrings(string s){
            string ns="@#";
            for(auto str:s){ns+=str;ns+='#';}
            ns+='!';
            s=ns;
            int sz=s.size()-1, ans=0;
            vector<int>dp(sz,1);
            int idx=0,mx=0;
            for(int i=1;i<sz;i++){
                if(i<mx)dp[i]=min(dp[2*idx-i], mx-i+1);
                else dp[i]=1;
                // 当i取0时，dp[i]取1，此时 i-dp[i]=-1
                while(s[i-dp[i]]==s[i+dp[i]]) dp[i]++;
                if(mx<i+dp[i]-1){
                    mx=i+dp[i]-1;
                    idx=i;
                }
                //cout<<dp[i]<<" ";
                ans+=(dp[i]/2);
            }
            return ans;
        }
};
```

**参考资料**

[Leetcode 647 回文子串](https://leetcode-cn.com/problems/palindromic-substrings)

### `Leetcode 730.` 统计不同回文子序列

$$
dp[i][j]=\left\{\begin{matrix}
dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1] \;if(s[i]!=s[j])
\\ 
dp[i+1][j-1]*2+\left\{\begin{matrix}
2\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;if(没有找到与s[i] 重复的字符)
\\ 
1\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;if(只有一个与s[i] 重复的字符)
\\ 
-dp[l+1][r-1] \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;if(存在多个与 s[i] 重复的字符)
\end{matrix}\right.
\end{matrix}\right.
$$



```cpp
int countPalindromicSubsequences(char * S){
    if(S == NULL || strlen(S) == 0)
        return 0;
    long long mod = 1000000007;
    int len = strlen(S);
    long dp[len][len];
    memset(dp, 0x0, sizeof(dp));

    for(int i = len - 1; i >= 0; i--)
    {
        dp[i][i] = 1;
        for(int j = i + 1; j < len; j++)
        {
            if(S[i] != S[j])
                dp[i][j] = dp[i + 1][j]/*以i+1为起点，j为末尾的字符串回文数*/ + dp[i][j - 1]/*以i为起点，j - 1为末尾的字符串回文数*/ - dp[i + 1][j - 1]/*以i+1为起点，j-1为末尾的字符串回文数被统计了两次*/;
            else
            {
                dp[i][j] = dp[i + 1][j - 1] * 2;
                int l = i + 1, r = j - 1;
                while(l <= r && S[l] != S[i]) l++; /* 从左侧开始查找相同的元素 */
                while(l <= r && S[r] != S[j]) r--; /* 从右侧开始查找相同的元素 */
                if(l > r) /* 没有找到重复字符 */
                    dp[i][j] += 2;
                else if(l == r) /* 只有一个重复字符 */
                    dp[i][j] += 1;
                else /* 找到重复字符了 */
                    dp[i][j] -= dp[l + 1][r - 1];
            }

            dp[i][j] = (dp[i][j] + mod) % mod;
            /*
                这是因为dp[i][j]是一个取模后的值，会有可能减去取模前的值变成一个负数，所以直接用
                dp[i][j] %= mod 是不对的，这样会依然为负数，需要加上mod偏移量，保证在结果在0-mod之间。
            */
        }
    }

    return dp[0][len - 1];
}

//作者：375D
//链接：https://leetcode-cn.com/problems/count-different-palindromic-//subsequences/solution/qu-jian-dp-by-375c-2/
//来源：力扣（LeetCode）
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### `Leetcode 516.`  最长回文子序列

 [Leetcode 516.最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

### `Leetcode 5. ` 最长回文子串

### `Leetcode 132.` 分割回文串 Ⅱ

## 其他

### `Leetcode 60.` 第 `k` 个排列

**问题描述**

给出集合 `[1,2,3,…,n]`，其所有元素共有 `n!` 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。
示例 1:

输入: n = 3, k = 3
输出: "213"

**解题报告**

`a[i]` 表示第 `i` 位【从右到左数】取 `1` 的排列数。

#### 实现代码

```cpp
class Solution {
public:
    string getPermutation(int n, int k) {
        vector<int>a={1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
        vector<bool>vis(n+1, false);
        string ans;
        for(int i=n-1;i>=0;i--){
            int cnt=a[i];
            for(int j=1;j<=n;j++){
                if(vis[j])continue;
                if(k>cnt){k-=cnt;continue;}
                vis[j]=true;
                ans+=to_string(j);
                break;
            }
        }
        return ans;
    }
};
```

**参考文献**

[Leetcode 60. 第 `k` 个排列](https://leetcode-cn.com/problems/permutation-sequence)

[题解区 liweiwei1419的评论区](https://leetcode-cn.com/problems/permutation-sequence/solution/hui-su-jian-zhi-python-dai-ma-java-dai-ma-by-liwei/)



# 前端相关

## 前端框架的渲染过程

1. 浏览器解析 `HTML` 生成 `DOM` 树。

   大致流程就是浏览器使用词法分析器和解析器将 `HTML` 内容解析成语法树，也就是 `DOM` 树

2. 浏览器将 `CSS` 资源解析成 `CSS Rule Tree`。

   类似于 `HTML` 解析。

3. `JS` 通过 `DOM API` 和 `CSSOM API` 来操作 `DOM` 树和 `CSS` 树

4. 解析完后综合 `DOM` 树和 `CSS` 树

## vue react angular三大框架对比

`vue.js` 框架是目前较火的 `MVVM` 框架之一，简单易上手的学习曲线，只需要掌握简单的 `html`、`css`、`js` 即可上手；友好的官方文档，且 `vue` 社区活跃，使用者较多；配套的构建工具，`vue-cli` 这个脚手架工具将所有的开发环境配置好了，开发者直接进行开发。

### vue 与 react

相同点：

1. 都使用 `Virtual DOM`。通过虚拟 `DOM` 结合 `diff` 算法，我们可以很好地解决 `DOM` 操作的性能问题，即 **生成虚拟 `DOM` 的时间 + `diff` 算法时间 + `patch` 时间 < 修改 `DOM` 的时间**。
2. 都使用了 响应式和组件化 的视图组件。组件大大提高了代码的复用性。
3. 两者均专注于视图框架，将其他功能如 **路由和全局状态管理** 交给相关的库，如 `router` 和 `vuex` 等
4. 两者都不需要触碰 `DOM`。

不同点：

1. `vue` 比 `react` 更容易上手。学习 `vue`，我们只需要掌握中级的 `html` 、`css`、`js` 即可。但是 `react` 的学习会更加复杂一些，`react` 需要有 `ES6` 的基础，另外对于 `JSX` 语法，还有一定的学习成本。
2. `vue` 的优化做的要比 `react` 好一些。在 `react` 应用中，当某个组件的状态发生变化时，它会以根组件为根，重新渲染整个组件子树。**如要避免不必要的子组件的重渲染**，你需要在所有可能的地方使用 `PureCompnent` 或者手动实现 `shouldComponentUpdate` 方法。同时你可能会使用不可变的数据结构来使得你的组件更容易被优化；但是在做 `vue` 相关的项目，我们只需要关注业务逻辑，而不需要去操心是否会产生不必要的组件渲染。

### vue 与 angular

相同点：

1. `angular` 和 `vue` 都使用了指令。指令是一个比较方便的操作。
2. `angular` 和 `vue` 都使用了双向数据绑定。

不同点：

1. `vue` 更容易上手。`angular` 需要学习 `typescript`，上手难度较大；
2. 性能上来说，`vue` 更好些。`angular` 依赖于定时的脏检查来进行视图的更新，当 `watcher` 越来越多时，脏检查越来越慢，作用域中的每一次变化，所有的 `watcher` 都要重新计算，并且如果一些 `watcher` 出发另一个更新，脏检查循环可能要运行多次。而 `VUE` 中则没有这个问题，因为它使用基于依赖追终的观察系统并且异步队列更新，所有的数据变化都是独立差法，除非它们之间有明确的依赖关系。

## vue渲染



# Docker

Docker是一种轻量级的**虚拟化技术**

![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png)

# 灵活问题

## 自我介绍

面试官好，我叫周珊，是东南大学计算机专业的研究生，研究生期间参与了<江苏省司法厅人民调解及类案推荐的前端开发工作>，负责研发了<基于关键字提取的多标签文本分类方案>，并以此发表了一篇 `SCI` 论文。除此之外，我对操作系统、计算机网络、数据库、C++、数据结构有着较为扎实的掌握。

## 项目介绍

1. 项目背景

   我国医疗卫生事业改革和发展相对滞后，导致医患纠纷案件数量逐年上升。由此我们实验室配合江苏省司法厅开发了“医患纠纷人民调解以及类案推荐”平台。

2. 项目介绍

   我和实验室已经毕业的师姐负责了该平台的前端开发工作，实现的功能有1）纠纷登记；2）纠纷调解；3）类案推荐；4）数据可视化展示。使用的技术框架是 `vue`。

3. 项目成果

   目前该项目已经上线运营。



1. 项目背景

   实现 **类案推荐** 时，一开始用的 `ElasticSearch` 中自带的 **全文搜索** 进行推荐，但是这样只能在全文中匹配一些词语，准确率较低，所以我研究生期间之后的工作就是使用 **基于深度学习的方法** 对文书库中的文书打标签。

2. 项目介绍

   采取的技术方案是：首先采用基于序列标注的方法提取文书关键词，具体采用的模型是 `BiLSTM+CRF【双向长短时记忆网络+条件随机场】`，然后使用 `SVM【支持向量机】` 对关键词进行多标签分类。

3. 项目成果

   一方面，将打了标签的文书更新到上线的系统中去了；另一方面，以该方案发表了一篇 `SCI` 论文并已接收。

## 项目难点

**前端项目**

在纠纷登记时，**纠纷信息** 包括用户相关的个人信息、用户医疗过程数据等，这些数据需要一次性发送给后台，

所以关于个人信息、医疗过程信息的登记都在同一级子组件中，其中在 **医疗过程信息登记** 中，

它包括多个流程【多流程且流程数量是不确定的】-》医疗过失行为大类【多个过失行为大类】-》医疗过失行为小类 

 这些 医疗过程信息需要在一个页面展示。这里面又涉及了子组件和父组件的通信。

在这个环节调试了很久才调试成功。



管理相关

诊断相关

用药相关

。。。

一次医疗案件涉及好几个流程，每个流程涉及到涉事科室，医疗过失行为，而医疗过失行为



**解决方案**



**深度学习项目**

比较困难的是 **如何确定解决方案**。

因为医患类裁判文书篇幅较长，直接基于全文进行分类会导致特征项不突出甚至被忽略，所以发现文书中一些表意完整、所指明确的关键性名词短语能够较为容易的确定文书的科室类别，所以最终采用基于 **序列标注** 方式提取上述的关键词，然后基于关键词进行分类。

**解决方案**



**关键词：团队合作、友好沟通**



## 项目收获

* 从前端开发项目中，与人沟通的能力；排错能力；代码能力；学习能力都得到一定程度上的提升。
* 从深度学习项目中，阅读英文文献、从数据本身出发进行建模分析的能力得到了一定程度上的提升。

## 对项目最满意的地方

1. 在医患纠纷调节前端项目中，有一个功能模块是关于医患纠纷案件的可视化展示
   * 比如从后台拉取数据，在前端进行展示，比如说将拉取的案件数据按照纠纷处理方式、地区进行展示；调解机构的员工在前端页面填报一些信息并提交到后台数据库中。
   * 当时负责后台开发的两个师兄有其他事情，所以我一个人边学习师兄发给我的代码边实现数据统计、展示、提交功能，在三天时间里独立完成了前端和后台工作的闭环。
   * 需要处理的数据比较多，需要展示的内容比较多。

## 团队分工

针对前端开发的项目，刚开始时，我和师姐两个人都没有基础，所以就两个人一起做一个功能模块，按照每个页面进行划分，写完之后进行交流学习；后来我们就按照功能模块进行划分，比如师姐负责了**纠纷调解模块**，我就负责了**案件信息可视化展示模块**。



针对文书的多标签分类方案，则主要是和老师沟通的

## 如何看待华为的企业文化

华为崇尚的是狼性文化，我也很认可这种企业文化，我个人非常希望能在这样的民族企业中培养自我。

## 如何看待加班

我觉得任何一个企业都可能加班。如果是自己的工作没有按时完成，那么自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。

## 简要介绍一下论文

因为医患类裁判文书篇幅较长，直接基于全文进行分类会导致特征项不突出甚至被忽略，所以发现文书中一些表意完整、所指明确的关键性名词短语能够较为容易的确定文书的科室类别，所以最终采用基于 **序列标注** 方式提取上述的关键词，然后基于关键词进行分类。

## 最近在读的书

《程序员的自我修养-链接、装载与库》因为最近在复习知识，发现好多关于程序编译过程的具体细节理解的不是很透彻，所以就学习了一下。

## 为什么选择这本书

## 自我评价

我做事谨慎小心，喜欢并善于总结；学习过程中喜欢对知识追本溯源。

这样的话，既有好的一面，也会有坏的一面。



## 优点和缺点

缺点：

优点：责任心比较强，做事比较负责。本科期间，从大二到大四一直都担任班级里的学习委员，每逢期末考试，我都会将各科复习资料准备妥当然后发给全班共享。最后我们班全体同学都正常毕业。

## 最有成就的事情

研究生期间从零到一做的关于医疗纠纷调解的前端开发项目。因为

## 最大的挫折，如何解决？

中规中矩的人生经历吧。

初中经历吧。

## 爱好

跑步。

## 职业规划

入职的2-3年里着重加宽自己的技术栈，希望自己能够独立带队开发一个大型项目吧。

# C++和Java的异同

## 异

1. `C++` 和 `java` 相比，只有标准的容器和算法，它的标准里没有网络、`GUI` 以及应用框架这些内容，因此需要第三方的库来支持。而 `Java` 的标准库包含的内容很丰富，有 `GUI` 支持，网络支持，多线程支持，以及完整的应用框架。
2. `C++` 中有指针可以直接操纵内存，这点是 `Java` 做不到的，`C++` 中的引用和 `Java` 中的引用不同。C++中的引用是编译时的一种隔离措施，也就是说，C++程序运行时，并没有引用存在。而java中的引用在程序运行期间，执行栈中存储引用，而堆中存储引用所执行的对象，因此java中的引用更像c++中的指向动态内存的指针。java有垃圾回收机制，C++需要显式的释放。
3. C++比java强大，灵活，快速。C++的执行需要借助C运行，而java执行需要借助JVM，jvm要借助C运行。
4. C++支持多重继承，这是C++的一个特征，它允许多父类派生一个类。尽管多重继承功能很强，但使用复杂，而且会引起许多麻烦，编译程序实现它也很不容易。Java不支持多重继承，但允许一个类继承多个接口，实现了C++多重继承的功能，又避免了C++中的多重继承实现方式带来的诸多不便？
5. java不支持操作符重载。
6. C/C++支持自动强制类型转换问题，java需要程序显式进行强制类型转换。

















